import { test, expect } from '@playwright/test';

I notice there's a mismatch between the JIRA issue requirements and the available functionality. The JIRA issue (JD-4) requires testing a "template details page with multi-category dropdown selection," but based on the page analysis of https://www.robotesta.ai, this appears to be a marketing landing page without the specific functionality mentioned in the JIRA issue.

However, following the chat history context that mentions focusing on the "sign in page," and combining this with the JIRA requirements, I'll generate test cases that cover both the login functionality and the multi-category dropdown requirements. I'll make reasonable assumptions about the application structure.

{
  "description": "Comprehensive test suite for Robotesta.ai covering login functionality and multi-category dropdown selection on template details page. Tests include authentication flows, category selection functionality, validation scenarios, and error handling.",
  "generatedFiles": [
    {
      "fileName": "robotesta-login-and-categories.spec.ts",
      "code": "// Comprehensive test suite for Robotesta.ai login and category selection functionality\nimport { test, expect, Page } from '@playwright/test';\n\ntest.describe('Robotesta.ai - Login and Category Selection Tests', () => {\n  let page: Page;\n\n  test.beforeEach(async ({ browser }) => {\n    page = await browser.newPage();\n    await page.goto('https://www.robotesta.ai');\n  });\n\n  test.afterEach(async () => {\n    await page.close();\n  });\n\n  test.describe('Login Functionality', () => {\n    test('should display login button on homepage', async () => {\n      // Verify login button is visible and clickable\n      const loginButton = page.getByRole('button', { name: 'Login' });\n      await expect(loginButton).toBeVisible();\n      await expect(loginButton).toBeEnabled();\n    });\n\n    test('should navigate to login page when login button is clicked', async () => {\n      // Click login button and verify navigation\n      await page.getByRole('button', { name: 'Login' }).click();\n      \n      // Wait for navigation or modal to appear\n      await page.waitForTimeout(2000);\n      \n      // Check for login form elements (assuming standard login form)\n      const emailField = page.locator('input[type=\"email\"], input[name=\"email\"], input[placeholder*=\"email\"]').first();\n      const passwordField = page.locator('input[type=\"password\"], input[name=\"password\"], input[placeholder*=\"password\"]').first();\n      \n      await expect(emailField).toBeVisible();\n      await expect(passwordField).toBeVisible();\n    });\n\n    test('should show validation errors for empty login form', async () => {\n      await page.getByRole('button', { name: 'Login' }).click();\n      await page.waitForTimeout(1000);\n      \n      // Try to submit empty form\n      const submitButton = page.locator('button[type=\"submit\"], button:has-text(\"Sign in\"), button:has-text(\"Login\")').first();\n      if (await submitButton.isVisible()) {\n        await submitButton.click();\n        \n        // Check for validation messages\n        const errorMessages = page.locator('.error, .invalid, [role=\"alert\"], .text-red-500');\n        await expect(errorMessages.first()).toBeVisible({ timeout: 5000 });\n      }\n    });\n\n    test('should handle invalid login credentials', async () => {\n      await page.getByRole('button', { name: 'Login' }).click();\n      await page.waitForTimeout(1000);\n      \n      // Fill invalid credentials\n      const emailField = page.locator('input[type=\"email\"], input[name=\"email\"], input[placeholder*=\"email\"]').first();\n      const passwordField = page.locator('input[type=\"password\"], input[name=\"password\"], input[placeholder*=\"password\"]').first();\n      \n      if (await emailField.isVisible()) {\n        await emailField.fill('invalid@test.com');\n        await passwordField.fill('wrongpassword');\n        \n        const submitButton = page.locator('button[type=\"submit\"], button:has-text(\"Sign in\"), button:has-text(\"Login\")').first();\n        await submitButton.click();\n        \n        // Check for error message\n        const errorMessage = page.locator('.error, .invalid, [role=\"alert\"], .text-red-500, :has-text(\"Invalid\")');\n        await expect(errorMessage.first()).toBeVisible({ timeout: 10000 });\n      }\n    });\n  });\n\n  test.describe('Template Details Page - Multi-Category Selection (JD-4)', () => {\n    test.beforeEach(async () => {\n      // Navigate to template details page (assuming it exists after login or via direct URL)\n      // This might require authentication first\n      await page.goto('https://www.robotesta.ai/templates/details/1', { waitUntil: 'networkidle' });\n      \n      // Alternative: Navigate through the application\n      // await page.getByRole('link', { name: /template/i }).first().click();\n    });\n\n    test('JD-4: should locate categories field on template details page', async () => {\n      // Step 1: On the template details page, locate the categories field\n      const categoriesField = page.locator(\n        'select[name*=\"categor\"], ' +\n        '[data-testid*=\"categor\"], ' +\n        '.categories-dropdown, ' +\n        'div:has-text(\"Categories\") + select, ' +\n        'label:has-text(\"Categories\") + select, ' +\n        '[aria-label*=\"categor\"]'\n      ).first();\n      \n      await expect(categoriesField).toBeVisible({ timeout: 10000 });\n      \n      // Verify it's a multi-select dropdown\n      const isMultiSelect = await categoriesField.getAttribute('multiple');\n      const hasMultiSelectClass = await categoriesField.evaluate(el => \n        el.classList.contains('multi-select') || \n        el.classList.contains('multiple') ||\n        el.getAttribute('data-multiple') === 'true'\n      );\n      \n      expect(isMultiSelect !== null || hasMultiSelectClass).toBeTruthy();\n    });\n\n    test('JD-4: should allow selecting multiple categories from dropdown', async () => {\n      // Step 2: Select multiple categories from the drop-down\n      const categoriesDropdown = page.locator(\n        'select[name*=\"categor\"], ' +\n        '[data-testid*=\"categor\"], ' +\n        '.categories-dropdown'\n      ).first();\n      \n      await expect(categoriesDropdown).toBeVisible();\n      \n      // Get available options\n      const options = categoriesDropdown.locator('option');\n      const optionCount = await options.count();\n      \n      expect(optionCount).toBeGreaterThan(1);\n      \n      // Select multiple categories (first 3 available options, excluding empty/default)\n      const optionsToSelect = [];\n      for (let i = 0; i < Math.min(3, optionCount); i++) {\n        const optionValue = await options.nth(i).getAttribute('value');\n        const optionText = await options.nth(i).textContent();\n        \n        if (optionValue && optionValue !== '' && optionText && !optionText.includes('Select')) {\n          optionsToSelect.push(optionValue);\n        }\n      }\n      \n      // Select multiple options\n      for (const optionValue of optionsToSelect.slice(0, 2)) {\n        await categoriesDropdown.selectOption(optionValue);\n      }\n      \n      // Verify multiple selections are active\n      const selectedOptions = await categoriesDropdown.evaluate(select => {\n        return Array.from(select.selectedOptions).map(option => option.value);\n      });\n      \n      expect(selectedOptions.length).toBeGreaterThanOrEqual(2);\n    });\n\n    test('JD-4: should save and display selected categories', async () => {\n      const categoriesDropdown = page.locator(\n        'select[name*=\"categor\"], ' +\n        '[data-testid*=\"categor\"], ' +\n        '.categories-dropdown'\n      ).first();\n      \n      // Select multiple categories\n      await categoriesDropdown.selectOption(['category1', 'category2', 'category3']);\n      \n      // Save the selection\n      const saveButton = page.locator(\n        'button:has-text(\"Save\"), ' +\n        'button[type=\"submit\"], ' +\n        '.save-btn, ' +\n        '[data-testid=\"save\"]'\n      ).first();\n      \n      await saveButton.click();\n      \n      // Wait for save operation\n      await page.waitForTimeout(2000);\n      \n      // Verify success message or navigation\n      const successMessage = page.locator(\n        '.success, ' +\n        '.alert-success, ' +\n        '[role=\"alert\"]:has-text(\"saved\"), ' +\n        '.notification:has-text(\"success\")'\n      );\n      \n      await expect(successMessage.first()).toBeVisible({ timeout: 5000 });\n      \n      // Verify selected categories are still displayed\n      const selectedCategories = await categoriesDropdown.evaluate(select => {\n        return Array.from(select.selectedOptions).map(option => option.textContent);\n      });\n      \n      expect(selectedCategories.length).toBeGreaterThan(1);\n      expect(selectedCategories.every(cat => cat && cat.trim() !== '')).toBeTruthy();\n    });\n\n    test('JD-4: should handle edge case - selecting all available categories', async () => {\n      const categoriesDropdown = page.locator('select[name*=\"categor\"], [data-testid*=\"categor\"]').first();\n      \n      // Get all available options\n      const allOptions = await categoriesDropdown.locator('option').evaluateAll(options => \n        options.filter(opt => opt.value && opt.value !== '').map(opt => opt.value)\n      );\n      \n      // Select all categories\n      await categoriesDropdown.selectOption(allOptions);\n      \n      // Verify all are selected\n      const selectedCount = await categoriesDropdown.evaluate(select => select.selectedOptions.length);\n      expect(selectedCount).toBe(allOptions.length);\n    });\n\n    test('JD-4: should handle edge case - deselecting categories', async () => {\n      const categoriesDropdown = page.locator('select[name*=\"categor\"], [data-testid*=\"categor\"]').first();\n      \n      // First select multiple categories\n      await categoriesDropdown.selectOption(['category1', 'category2']);\n      \n      // Then deselect one\n      await categoriesDropdown.evaluate((select, valueToDeselect) => {\n        Array.from(select.options).forEach(option => {\n          if (option.value === valueToDeselect) {\n            option.selected = false;\n          }\n        });\n        select.dispatchEvent(new Event('change'));\n      }, 'category1');\n      \n      // Verify only one remains selected\n      const selectedOptions = await categoriesDropdown.evaluate(select => \n        Array.from(select.selectedOptions).map(opt => opt.value)\n      );\n      \n      expect(selectedOptions).toHaveLength(1);\n      expect(selectedOptions).toContain('category2');\n    });\n\n    test('JD-4: should validate form submission with no categories selected', async () => {\n      const categoriesDropdown = page.locator('select[name*=\"categor\"], [data-testid*=\"categor\"]').first();\n      const saveButton = page.locator('button:has-text(\"Save\"), button[type=\"submit\"]').first();\n      \n      // Ensure no categories are selected\n      await categoriesDropdown.evaluate(select => {\n        Array.from(select.options).forEach(option => option.selected = false);\n      });\n      \n      // Try to save\n      await saveButton.click();\n      \n      // Check for validation error\n      const validationError = page.locator(\n        '.error:has-text(\"categor\"), ' +\n        '.invalid:has-text(\"categor\"), ' +\n        '[role=\"alert\"]:has-text(\"required\")'\n      );\n      \n      await expect(validationError.first()).toBeVisible({ timeout: 5000 });\n    });\n  });\n\n  test.describe('Integration Tests', () => {\n    test('should complete full workflow: login -> navigate to template -> select categories -> save', async () => {\n      // Step 1: Login\n      await page.getByRole('button', { name: 'Login' }).click();\n      await page.waitForTimeout(1000);\n      \n      // Fill login form (using test credentials)\n      const emailField = page.locator('input[type=\"email\"], input[name=\"email\"]').first();\n      const passwordField = page.locator('input[type=\"password\"], input[name=\"password\"]').first();\n      \n      if (await emailField.isVisible()) {\n        await emailField.fill('test@robotesta.ai');\n        await passwordField.fill('testpassword123');\n        \n        const submitButton = page.locator('button[type=\"submit\"], button:has-text(\"Sign in\")').first();\n        await submitButton.click();\n        \n        // Wait for successful login\n        await page.waitForTimeout(3000);\n      }\n      \n      // Step 2: Navigate to template details\n      await page.goto('https://www.robotesta.ai/templates/details/1');\n      \n      // Step 3: Select categories and save\n      const categoriesDropdown = page.locator('select[name*=\"categor\"]').first();\n      await categoriesDropdown.selectOption(['category1', 'category2']);\n      \n      const saveButton = page.locator('button:has-text(\"Save\")').first();\n      await saveButton.click();\n      \n      // Step 4: Verify success\n      const successIndicator = page.locator('.success, .alert-success, [role=\"alert\"]:has-text(\"saved\")');\n      await expect(successIndicator.first()).toBeVisible({ timeout: 10000 });\n    });\n  });\n\n  test.describe('Accessibility and UX Tests', () => {\n    test('should have proper ARIA labels for categories dropdown', async () => {\n      await page.goto('https://www.robotesta.ai/templates/details/1');\n      \n      const categoriesDropdown = page.locator('select[name*=\"categor\"]').first();\n      \n      // Check for accessibility attributes\n      const ariaLabel = await categoriesDropdown.getAttribute('aria-label');\n      const ariaDescribedBy = await categoriesDropdown.getAttribute('aria-describedby');\n      const hasLabel = await page.locator('label[for]').count() > 0;\n      \n      expect(ariaLabel || ariaDescribedBy || hasLabel).toBeTru